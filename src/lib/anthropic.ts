// import { OpenRouter } from '@openrouter/sdk';
// import { Octokit } from '@octokit/rest';

// const openRouterApiKey = process.env.OPENROUTER_API_KEY!;
// const githubToken = process.env.GITHUB_TOKEN!;

// export async function generateApp(userPrompt: string) {
//     const openRouter = new OpenRouter({
//         apiKey: openRouterApiKey,
//     });

//     const response = await openRouter.chat.send({
//         model: 'openai/gpt-4o',
//         messages: [
//             {
//                 role: 'user',
//                 content: userPrompt,
//             },
//         ],
//         stream: true,
//         streamOptions: { includeUsage: true }
//     });

//     let appFiles: Array<string> = [];

//     for await (const part of response) {
//         // Collect streamed data and process
//         const content = part.choices[0]?.delta.content;
//         if (content) {
//             appFiles.push(content);
//         }
//     }
//     return appFiles;
// }

// export async function createGitHubRepo(projectData: { name: string; files: any[] }, userGitHubToken: string) {
//     const octokit = new Octokit({ auth: userGitHubToken });

//     try {
//         const { data: repo } = await octokit.repos.createForAuthenticatedUser({
//             name: projectData.name,
//             description: 'Generated by OpenRouter and deployed via GitGenius',
//             private: false,
//             auto_init: true,
//         });

//         for (const file of projectData.files) {
//             await octokit.repos.createOrUpdateFileContents({
//                 owner: repo.owner.login,
//                 repo: repo.name,
//                 path: file.path,
//                 message: `Add ${file.path}`,
//                 content: Buffer.from(file.content).toString('base64'),
//             });
//         }

//         return repo.html_url;
//     } catch (error: any) {
//         console.error('GitHub Error:', error);
//         throw new Error('Failed to create repo and upload files.');
//     }
// }

import { OpenRouter } from '@openrouter/sdk';
import { Octokit } from '@octokit/rest';

const openRouterApiKey = process.env.OPENROUTER_API_KEY!;
const githubToken = process.env.GITHUB_TOKEN!;

interface FileData {
    path: string;
    content: string;
}

// export async function generateApp(userPrompt: string): Promise<FileData[]> {
//     const openRouter = new OpenRouter({
//         apiKey: openRouterApiKey,
//     });

//     // Enhanced prompt to get structured output
//     const systemPrompt = `You are a code generator. Generate a complete app based on the user's request.
// Return your response as a JSON array of files with this exact structure:
// [
//   {
//     "path": "index.html",
//     "content": "<!DOCTYPE html>..."
//   },
//   {
//     "path": "style.css",
//     "content": "body { ... }"
//   }
// ]

// IMPORTANT: Return ONLY the JSON array, no markdown code blocks, no explanations.`;

//     const response = await openRouter.chat.send({
//         model: 'openai/gpt-4o',
//         messages: [
//             {
//                 role: 'system',
//                 content: systemPrompt,
//             },
//             {
//                 role: 'user',
//                 content: userPrompt,
//             },
//         ],
//         stream: true,
//         streamOptions: { includeUsage: true }
//     });

//     let fullResponse = '';

//     // Collect all streamed chunks
//     for await (const part of response) {
//         const content = part.choices[0]?.delta?.content;
//         if (content) {
//             fullResponse += content;
//         }
//     }

//     // Parse the JSON response
//     try {
//         // Remove markdown code blocks if present
//         let jsonString = fullResponse.trim();
//         if (jsonString.startsWith('```json')) {
//             jsonString = jsonString.replace(/```json\n?/g, '').replace(/```\n?/g, '');
//         } else if (jsonString.startsWith('```')) {
//             jsonString = jsonString.replace(/```\n?/g, '');
//         }

//         const files: FileData[] = JSON.parse(jsonString);

//         // Validate structure
//         if (!Array.isArray(files)) {
//             throw new Error('Response is not an array');
//         }

//         for (const file of files) {
//             if (!file.path || !file.content) {
//                 throw new Error('Invalid file structure: missing path or content');
//             }
//         }

//         return files;
//     } catch (error) {
//         console.error('Failed to parse AI response:', error);
//         console.error('Raw response:', fullResponse);
//         throw new Error('AI did not return valid JSON file structure');
//     }
// }

export async function generateApp(userPrompt: string): Promise<FileData[]> {
    const openRouter = new OpenRouter({
        apiKey: openRouterApiKey,
    });

    const systemPrompt = `You are a code generator. Generate a complete app based on the user's request.
Return your response as a JSON array of files with this exact structure:
[
  {
    "path": "index.html",
    "content": "<!DOCTYPE html>..."
  },
  {
    "path": "style.css",
    "content": "body { ... }"
  }
]

IMPORTANT: Return ONLY the JSON array, no markdown code blocks, no explanations.`;

    const response = await openRouter.chat.send({
        model: 'openai/gpt-4o',
        messages: [
            {
                role: 'system',
                content: systemPrompt,
            },
            {
                role: 'user',
                content: userPrompt,
            },
        ],
        stream: false,
    });

    // Handle both string and array content
    const rawContent = response.choices[0]?.message?.content;
    let content = '';

    if (typeof rawContent === 'string') {
        content = rawContent;
    } else if (Array.isArray(rawContent)) {
        // Extract text from content items
        content = rawContent
            .map(item => {
                if ('text' in item) return item.text;
                return '';
            })
            .join('');
    }

    // Parse JSON
    try {
        let jsonString = content.trim();

        // Remove markdown code blocks if present
        jsonString = jsonString.replace(/```json\n?/g, '').replace(/```\n?/g, '');

        const files: FileData[] = JSON.parse(jsonString);

        // Validate structure
        if (!Array.isArray(files)) {
            throw new Error('Response is not an array');
        }

        for (const file of files) {
            if (!file.path || !file.content) {
                throw new Error('Invalid file structure: missing path or content');
            }
        }

        return files;
    } catch (error) {
        console.error('Failed to parse AI response:', error);
        console.error('Raw content:', content);
        throw new Error('AI did not return valid JSON file structure');
    }
}

export async function createGitHubRepo(
    projectName: string,
    files: FileData[],
    userGitHubToken: string
): Promise<string> {
    const octokit = new Octokit({ auth: userGitHubToken });

    try {
        // Create the repository
        const { data: repo } = await octokit.repos.createForAuthenticatedUser({
            name: projectName,
            description: 'Generated by OpenRouter and deployed via GitGenius',
            private: false,
            auto_init: true,
        });

        console.log(`Repository created: ${repo.html_url}`);

        // Wait a bit for repo initialization
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Upload each file
        for (const file of files) {
            console.log(`Uploading ${file.path}...`);

            await octokit.repos.createOrUpdateFileContents({
                owner: repo.owner.login,
                repo: repo.name,
                path: file.path,
                message: `Add ${file.path}`,
                content: Buffer.from(file.content).toString('base64'),
            });
        }

        return repo.html_url;
    } catch (error: any) {
        console.error('GitHub Error:', error.message);
        if (error.response) {
            console.error('Response data:', error.response.data);
        }
        throw new Error(`Failed to create repo: ${error.message}`);
    }
}